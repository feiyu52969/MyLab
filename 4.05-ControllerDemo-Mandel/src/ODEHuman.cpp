//ODEHuman.cpp
//--------------------** Description ** -----------------------------------------------
// a set of joints and rigid boxes representing a human figure
// May be posed using a Posture and the state of the simulation can be returned as a Posture
//-------------------------------------------------------------------------------------
//Copyright 2004 Michael J Mandel
/*
History:
5/10/04 - created MJM
*/

#include "ODEHuman.h"
#include "ODESimulation.h"
#include "ODEBox.h"
#include "glut.h"

//cap the torque generated by the controller to a reasonable value
#define MAX_TORQUE 60.0

ODEHuman::ODEHuman(const ODEPosition &humanPos, ODESimulation *sim, bool hasBody) : ODEObject(sim, hasBody), mEnabled(false),  mControllerEnabled(false), mControllerState(PDSTATE_NONE)
{

	SetControllerProperties(controlPropsDefault);

	CreateBodiesAndJoints(humanPos);

	SetEnabled(true);
}

ODEHuman::~ODEHuman()
{
	//remove all bodies from the simulation
	std::vector<ODEBox*>::iterator it;
	for (it = rigidLinks.begin() ; it != rigidLinks.end() ; it++)
	{
		delete (*it); //ODEBox destructor will take care of the rest
	}

	mBodyID = 0;
	mGeomID = 0;
}

//creates all the joints and bodies for a human in a reference, or base posture
void ODEHuman::CreateBodiesAndJoints(const ODEPosition &humanPos, bool allowAttachToWorld)
{
	rigidLinks.resize(NUM_BODY_PARTS);
	rigidJoints.resize(NUM_BODY_PARTS);

	//create all the bodies
	for(int i = 0 ; i < NUM_BODY_PARTS ; i++)
	{
		ODEBox *newBox = new ODEBox(bodyProps[i].size, mSimulator, true);
		rigidLinks[i] = newBox;
		newBox->SetID(i);
		newBox->SetMass(bodyProps[i].mass);

		if(i == lowerback)
		{
			mBodyID = newBox->GetBodyID();
			mGeomID = newBox->GetGeomID();
		}

		newBox->SetPos(bodyProps[i].pos);
		newBox->SetRot(bodyProps[i].rot);

		//bodies will be enabled when joints are created
		newBox->SetEnabled(false);
	}


	//create joints
	dJointID newJoint = 0;
	for(i = 0 ; i < NUM_BODY_PARTS ; i++)
	{
		odeJointProperty curProp = jointProps[i];

		if(bodyProps[curProp.attachedBody].enabled )
		{
			if(curProp.attachToWorld && !allowAttachToWorld)
				continue;

			switch(curProp.jointType)
			{
				case JOINT_TYPE_HINGE:

					newJoint = dJointCreateHinge(mSimulator->GetWorldID(), 0);
					rigidJoints[curProp.attachedBody] = newJoint;
					if(curProp.attachToWorld)
						dJointAttach(newJoint, rigidLinks[curProp.attachedBody]->GetBodyID(), 0);
					else
						dJointAttach(newJoint, rigidLinks[curProp.attachedBody]->GetBodyID(), rigidLinks[curProp.parentBody]->GetBodyID());

					dJointSetHingeAnchor(newJoint, WORLD_TO_SIM(curProp.jointAnchor[0]), WORLD_TO_SIM(curProp.jointAnchor[1]), WORLD_TO_SIM(curProp.jointAnchor[2]));
					dJointSetHingeAxis(newJoint, curProp.rotAxis1[0], curProp.rotAxis1[1], curProp.rotAxis1[2]);
 
					//joint limit constraints
					if(!(curProp.attachToWorld))
					{
						//set them twice to make sure it "sticks"
						dJointSetHingeParam (newJoint, dParamLoStop, curProp.loJointRange1);
						dJointSetHingeParam (newJoint, dParamHiStop, curProp.highJointRange1);
						dJointSetHingeParam (newJoint, dParamLoStop, curProp.loJointRange1);
						dJointSetHingeParam (newJoint, dParamHiStop, curProp.highJointRange1);
					}
				break;

				case JOINT_TYPE_UNIVERSAL:

					newJoint = dJointCreateUniversal(mSimulator->GetWorldID(), 0);
					rigidJoints[curProp.attachedBody] = newJoint;
					if(curProp.attachToWorld)
						dJointAttach(newJoint, rigidLinks[curProp.attachedBody]->GetBodyID(), 0);
					else
						dJointAttach(newJoint, rigidLinks[curProp.attachedBody]->GetBodyID(), rigidLinks[curProp.parentBody]->GetBodyID());

					dJointSetUniversalAnchor(newJoint, WORLD_TO_SIM(curProp.jointAnchor[0]), WORLD_TO_SIM(curProp.jointAnchor[1]), WORLD_TO_SIM(curProp.jointAnchor[2]));


					dJointSetUniversalAxis1(newJoint, curProp.rotAxis1[0], curProp.rotAxis1[1], curProp.rotAxis1[2]); 
					dJointSetUniversalAxis2(newJoint, curProp.rotAxis2[0], curProp.rotAxis2[1], curProp.rotAxis2[2]);

					//joint limit constraints
					if(!(curProp.attachToWorld))
					{
						//set them twice to make sure it "sticks"
						dJointSetUniversalParam (newJoint, dParamLoStop, curProp.loJointRange1);
						dJointSetUniversalParam (newJoint, dParamHiStop, curProp.highJointRange1);
						dJointSetUniversalParam (newJoint, dParamLoStop, curProp.loJointRange1);
						dJointSetUniversalParam (newJoint, dParamHiStop, curProp.highJointRange1);
						dJointSetUniversalParam (newJoint, dParamLoStop2, curProp.loJointRange2);
						dJointSetUniversalParam (newJoint, dParamHiStop2, curProp.highJointRange2);
						dJointSetUniversalParam (newJoint, dParamLoStop2, curProp.loJointRange2);
						dJointSetUniversalParam (newJoint, dParamHiStop2, curProp.highJointRange2);
					}
				break;
				
				default:
				break;
			}

			rigidLinks[i]->SetEnabled(true);
		}

	}
	

	//disable collisions between hips and upper arms since they are
	//not connected, but may be touching
	rigidLinks[lhipjoint]->DisableCollisionsWith(rigidLinks[rhipjoint]);
	rigidLinks[lclavicle]->DisableCollisionsWith(rigidLinks[rclavicle]);
;
}

//add a force to a particular body
void ODEHuman::AddForceToBody(int bodyID, const ODEVector &force)
{
	ODEBox *body = GetBody(bodyID);

	if(body)
	{
		body->AddForce(force);
	}
}

//enable/disable all bodies and joints
void ODEHuman::SetEnabled(bool b)
{
	mEnabled = b;

	//loop through all bodies and enable them
	for(int i = 0 ; i < NUM_BODY_PARTS ; i++)
	{
		odeJointProperty curProp = jointProps[i];

		//enable appropriate bodies
		if(mEnabled && bodyProps[curProp.attachedBody].enabled)
		{
			rigidLinks[curProp.attachedBody]->SetEnabled(true);

			if(!curProp.attachToWorld)
				rigidLinks[curProp.parentBody]->SetEnabled(true);
		}
		else if(!mEnabled)
		{
			rigidLinks[curProp.attachedBody]->SetEnabled(false);
		}

	}
}



void ODEHuman::Render()
{
	//individual bodies will be rendered automatically because they are ODEObjects....
}

//compute and apply PD-controller torques to each body part
void ODEHuman::applyControlTorques()
{
	if(mControllerEnabled)
	{	
		for(int i = 0 ; i < NUM_BODY_PARTS ; i++)
		{
			odeControlProperty curControlProp = mCurControllerPropsCopy[i];
			odeJointProperty curJointProp = jointProps[i];

			if(curControlProp.isControllable && bodyProps[curJointProp.attachedBody].enabled && !curJointProp.attachToWorld)
			{

				float curAngleX, curVelX, curAngleY, curVelY;
				float torqueX, torqueY;
				torqueX = torqueY = 0.0f;

				//extract desired joint angles
				float desiredX = mControllerPose[2*i];
				float desiredY = mControllerPose[2*i + 1];

				// Apply the torques
				switch(curJointProp.jointType)
				{
					case JOINT_TYPE_HINGE:
						//get current angle
						curAngleX = dJointGetHingeAngle(rigidJoints[curJointProp.attachedBody]);
						//get current speed
						curVelX = dJointGetHingeAngleRate (rigidJoints[curJointProp.attachedBody]);
						//compute torque
						torqueX = curControlProp.ks1*(desiredX - curAngleX) - curControlProp.kd1*curVelX;

						//apply maximum torque constraint
						if(torqueX > MAX_TORQUE)
							torqueX = MAX_TORQUE;
						if(torqueX < -MAX_TORQUE)
							torqueX = -MAX_TORQUE;

						dJointAddHingeTorque(rigidJoints[curJointProp.attachedBody], torqueX);
					break;

					case JOINT_TYPE_UNIVERSAL:
						//get current angle
						curAngleX = dJointGetUniversalAngle1(rigidJoints[curJointProp.attachedBody]);
						curAngleY = dJointGetUniversalAngle2(rigidJoints[curJointProp.attachedBody]);
						//get current speed
						curVelX = dJointGetUniversalAngle1Rate (rigidJoints[curJointProp.attachedBody]);
						curVelY = dJointGetUniversalAngle2Rate (rigidJoints[curJointProp.attachedBody]);
						//compute torque
						torqueX = curControlProp.ks1*(desiredX - curAngleX) - curControlProp.kd1*curVelX;
						torqueY = curControlProp.ks2*(desiredY - curAngleY) - curControlProp.kd2*curVelY;

						//apply maximum torque constraint
						if(torqueX > MAX_TORQUE)
							torqueX = MAX_TORQUE;
						if(torqueY > MAX_TORQUE)
							torqueY = MAX_TORQUE;
						if(torqueX < -MAX_TORQUE)
							torqueX = -MAX_TORQUE;
						if(torqueY < -MAX_TORQUE)
							torqueY = -MAX_TORQUE;

						dJointAddUniversalTorques(rigidJoints[curJointProp.attachedBody], torqueX,torqueY);
					break;
					
					default:

					break;
				}
			}
		}
	}
}

//set the current state of the controller 
void ODEHuman::SetControllerState(PDControlState s) 
{ 

	//set the desired pose for the new controller state
	if(mControllerState != s)
	{
		mControllerState = s; 

		mControllerStateTimer.Stamp();

		SetControllerProperties(controlPropsDefault);

		switch(s)
		{
			case PDSTATE_NONE:
			break;

			case PDSTATE_BASE_POSE:
				//zero all the joints to get into the base pose
				for(int i = 0 ; i < NUM_BODY_PARTS ; i++)
				{
					mControllerPose[2*i] = 0.0f;
					mControllerPose[2*i + 1] = 0.0f;
				}
			break;

			case PDSTATE_ARMS_FORWARD_LEGS_TOGETHER:
				for(int i = 0 ; i < NUM_BODY_PARTS ; i++)
				{
					//zero all the joints except arms and legs
					if((i != lhumerus) && (i != rhumerus) &&  //upper arms
					   (i != lfemur) && (i != rfemur)) //upper legs
					{
						mControllerPose[2*i] = 0.0f;
						mControllerPose[2*i + 1] = 0.0f;
					}
					else if((i == lhumerus) || (i == rhumerus))
					{
						mControllerPose[2*i] = 85.0f*DEG_TO_RAD;
						mControllerPose[2*i + 1] = 0.0f;
					}
					else if(i == lfemur)
					{
						mControllerPose[2*i] = 0.0f;
						mControllerPose[2*i + 1] = -18.0f*DEG_TO_RAD;
					}
					else if(i == rfemur)
					{
						mControllerPose[2*i] = 0.0f;
						mControllerPose[2*i + 1] = 18.0f*DEG_TO_RAD;
					}
				}
			break;

			case PDSTATE_ARMS_DOWN_KNEES_BENT:
				//zero all the joints except arms and legs
				for(int i = 0 ; i < NUM_BODY_PARTS ; i++)
				{
					if((i != lhumerus) && (i != rhumerus) && //upper arms
					   (i != ltibia) && (i != rtibia) )      //knees
					{
						mControllerPose[2*i] = 0.0f;
						mControllerPose[2*i + 1] = 0.0f;
					}
					else if((i == lhumerus) || (i == rhumerus))
					{
						mControllerPose[2*i] = 0.0f;
						mControllerPose[2*i + 1] = -65.0f*DEG_TO_RAD;
					}
					else if((i == ltibia) || (i == rtibia))
					{
						mControllerPose[2*i] = 85.0f*DEG_TO_RAD;
						mControllerPose[2*i + 1] = 0.0f;
					}
				}
			break;

			default: 
			break;
		}
	}
}

//set the controller gains used by the controller (a copy is made)
void ODEHuman::SetControllerProperties(odeControlProperty *props)
{
	if(props)
	{
		mCurControllerProps = props;

		//store a copy of properties to allow them to change programatically (see ApplyScalingToControllerProps)
		memcpy(mCurControllerPropsCopy, mCurControllerProps, NUM_BODY_PARTS*sizeof(odeControlProperty));
	}
}

void ODEHuman::ScalePDGains(int i, float f)
{
	ScalePDDamperGain(i, f);
	ScalePDSpringGain(i, f);
}

void ODEHuman::ScalePDSpringGain(int i, float f)
{
	mCurControllerPropsCopy[i].ks1 =  f*mCurControllerProps[i].ks1;
	mCurControllerPropsCopy[i].ks2 =  f*mCurControllerProps[i].ks2;
}

void ODEHuman::ScalePDDamperGain(int i, float f)
{
	mCurControllerPropsCopy[i].kd1 =  f*mCurControllerProps[i].kd1;
	mCurControllerPropsCopy[i].kd2 =  f*mCurControllerProps[i].kd2;
}

//called every update to determine whether state transitions are necessary
void ODEHuman::handleControllerStateTransitions()
{
	if(!mControllerEnabled)
		return;

	PDControlState oldState, newState;
	oldState = newState = mControllerState;

	//using time based transitions between states for this demo...
	switch(oldState)
	{
		case PDSTATE_BASE_POSE:
			if(mControllerStateTimer.Elapsed() > 3.0f)
				newState = PDSTATE_ARMS_FORWARD_LEGS_TOGETHER;
		break;
		case PDSTATE_ARMS_FORWARD_LEGS_TOGETHER:
			if(mControllerStateTimer.Elapsed() > 3.0f)
				newState = PDSTATE_ARMS_DOWN_KNEES_BENT;
		break;
		case PDSTATE_ARMS_DOWN_KNEES_BENT:
			if(mControllerStateTimer.Elapsed() > 3.0f)
				newState = PDSTATE_BASE_POSE;
		break;

		default: break;
	}


	//set the new state
	if(newState != oldState)
	{
		SetControllerState(newState);
	}
}


//activates/deactivates the PD-controller
//NOTE: application must call SetControllerState() after enabling controller
void ODEHuman::EnableController(bool b) 
{ 
	if(b != mControllerEnabled)
	{
		mControllerEnabled = b; 

		if(b)
		{
			//application must explicitly set an initial state after enabling controller
			SetControllerState(PDSTATE_NONE);
		}
	}
}

bool ODEHuman::Update()
{
	//inidividual bodies will be updated automatically because they are ODEObjects

	//if the controller is enabled, we compute and apply the controller torques here
	if(GetControllerState() != PDSTATE_NONE)
	{
		handleControllerStateTransitions();
		applyControlTorques();
	}

	return true;
}